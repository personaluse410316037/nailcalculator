# Lo2cin4bt/main.py
"""
開發注意事項:
1. 保持 main.py 簡潔，僅負責流程協調。
2. 確保與 dataloader、statanalyser 和 backtester 的接口兼容。
3. 提供清晰的用戶交互，允許跳過統計分析或回測。
"""

# 先清理所有 logger 上的 RotatingFileHandler（或 FileHandler）
import logging
import logging.handlers
for name in logging.root.manager.loggerDict:
    logger = logging.getLogger(name)
    for h in list(logger.handlers):
        if isinstance(h, (logging.handlers.RotatingFileHandler, logging.FileHandler)):
            logger.removeHandler(h)

import pandas as pd
from dataloader import DataLoader
from statanalyser import (
    BaseStatAnalyser, CorrelationTest, StationarityTest,
    AutocorrelationTest, DistributionTest, SeasonalAnalysis, ReportGenerator
)
from backtester import DataImporter_backtester, Base_backtester
import openpyxl
import multiprocessing
import os
import numpy as np

pd.set_option('display.max_columns', None)
pd.set_option('display.width', 1000)
pd.set_option('display.max_colwidth', 20)

# 設定多進程安全的 logging
listener = None

def setup_logging():
    global listener
    log_dir = os.path.join(os.path.dirname(__file__), "logs")
    os.makedirs(log_dir, exist_ok=True)
    log_file = os.path.join(log_dir, "backtest_errors.log")

    log_queue = multiprocessing.Queue(-1)
    # 改用 FileHandler，不做輪替
    handler = logging.FileHandler(log_file, encoding='utf-8')
    formatter = logging.Formatter("[%(asctime)s] [%(levelname)s] [BacktestID: %(backtest_id)s] [%(name)s]: %(message)s")
    handler.setFormatter(formatter)
    listener = logging.handlers.QueueListener(log_queue, handler)
    listener.start()

    root_logger = logging.getLogger("lo2cin4bt")
    root_logger.setLevel(logging.DEBUG)
    root_logger.handlers = []
    root_logger.addHandler(logging.handlers.QueueHandler(log_queue))
    return listener

def standardize_data_for_stats(data):
    """將數據標準化為統計分析器期望的格式"""
    df = data.copy()
    
    # 將欄位名稱轉換為小寫
    df.columns = [col.lower() for col in df.columns]
    
    # 確保 time 欄位存在且格式正確
    if 'time' not in df.columns:
        if 'Time' in data.columns:
            df['time'] = data['Time']
        else:
            raise ValueError("數據中缺少 time 欄位")
    
    # 確保 time 欄位為 datetime 格式
    df['time'] = pd.to_datetime(df['time'])
    
    # 如果沒有收益率欄位，需要計算
    if 'close_return' not in df.columns:
        if 'close' in df.columns:
            # 計算收益率
            df['close_return'] = df['close'].pct_change()
            df['close_logreturn'] = np.log(df['close'] / df['close'].shift(1))
            df['open_return'] = df['open'].pct_change()
            df['open_logreturn'] = np.log(df['open'] / df['open'].shift(1))
            # 處理無限值和 NaN
            for col in ['close_return', 'close_logreturn', 'open_return', 'open_logreturn']:
                df[col] = df[col].replace([np.inf, -np.inf], np.nan).fillna(0)
            print("已計算收益率欄位")
        else:
            print("警告：缺少 close 欄位，無法計算收益率")
    
    return df

def main():
    setup_logging()
    print("啟動量化回測框架")

    # 載入數據
    importer = DataImporter_backtester()
    data, frequency = importer.load_and_standardize_data()
    if data is None:
        print("數據載入失敗，程式終止")
        return
    print("數據載入成功，概覽：")
    print(data.head())
    print("數據列名：", list(data.columns))

    # 詢問是否運行統計分析
    run_stats = input("\n是否運行統計分析？(y/n)：").strip().lower()
    if run_stats == 'y':
        # 標準化數據格式以符合統計分析器要求
        stats_data = standardize_data_for_stats(data)
        
        # 獲取用戶配置
        predictor_col, updated_data = BaseStatAnalyser.get_user_config(stats_data)

        # 選擇頻率
        freq = input("\n請輸入數據頻率以計算自相關性（D=日，H=小時，T=分鐘）：").strip().upper()
        freq = freq if freq in ['D', 'H', 'T'] else 'D'
        print(f"使用頻率：{freq}")

        # 初始化分析器
        analyzers = [
            CorrelationTest(updated_data, predictor_col, "close_return"),
            StationarityTest(updated_data, predictor_col, "close_return"),
            AutocorrelationTest(updated_data, predictor_col, "close_return", freq=freq),
            DistributionTest(updated_data, predictor_col, "close_return"),
            SeasonalAnalysis(updated_data, predictor_col, "close_return"),
        ]

        # 執行分析
        results = {}
        for analyzer in analyzers:
            test_name = f"{analyzer.__class__.__name__}_{analyzer.predictor_col}"
            try:
                results[test_name] = analyzer.analyze()
                print(f"\n=== {test_name} 結果已在終端展示 ===")
            except Exception as e:
                print(f"Error in {test_name}: {e}")
                results[test_name] = {"error": str(e)}

        # 保存報告
        reporter = ReportGenerator()
        reporter.save_report(results)
        reporter.save_data(updated_data, format="csv")

    # 詢問是否運行回測
    run_backtest = input("\n是否運行回測？(y/n)：").strip().lower()
    if run_backtest == 'y':
        backtester = Base_backtester(data, frequency)
        backtester.run_backtest()
    else:
        print("跳過回測，程式結束。")

    # 程式結束時停止 listener
    global listener
    if listener:
        listener.stop()

if __name__ == "__main__":
    main()
